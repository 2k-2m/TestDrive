from appium import webdriver
from appium.options.android import UiAutomator2Options
from appium.webdriver.common.appiumby import AppiumBy
from selenium.webdriver.support.ui import WebDriverWait
from selenium.common.exceptions import NoSuchElementException, TimeoutException
from selenium.webdriver.support import expected_conditions as EC
from datetime import datetime
import time
import csv
import random
import os

# --- Constantes para Nombres de MÃ©tricas ---
METRICA_CARGA_APP_A_FEED = "Carga_Feed"
METRICA_PUBLICACION_POST = "Publicacion"
METRICA_ENVIO_MSG_TEXTO = "Ms_Texto"
METRICA_ENVIO_MSG_FOTO = "Ms_Foto"
METRICA_ENVIO_MSG_VIDEO = "Ms_Video"


#FunciÃ³n de cÃ³digo para detectar red:
def obtener_estado_conectividad_real(driver):
    try:
        salida = driver.execute_script("mobile: shell", {
            'command': 'dumpsys connectivity',
            'args': [],
            'includeStderr': True,
            'timeout': 5000
        })['stdout']

        redes_conectadas = []
        for bloque in salida.split("NetworkAgentInfo")[1:]:
            if "state: CONNECTED" in bloque and "VALIDATED" in bloque:
                if "type: WIFI" in bloque:
                    redes_conectadas.append("WIFI")
                elif "type: MOBILE" in bloque:
                    redes_conectadas.append("MOBILE")

        if "WIFI" in redes_conectadas:
            return "WIFI"
        elif "MOBILE" in redes_conectadas:
            return "MOBILE"
        else:
            return "SIN_RED"

    except Exception as e:
        print(f"âš ï¸ Error al verificar conectividad real: {e}")
        return "SIN_RED"


def setup_driver():
    desired_caps = {
        "platformName": "Android",
        "deviceName": "R58M795NHZF",
        "appPackage": "com.instagram.android",
        "appActivity": "com.instagram.android.activity.MainTabActivity",
        "automationName": "UiAutomator2",
        "forceAppLaunch": True,
        "noReset": True,
        "newCommandTimeout": 360
    }
    options = UiAutomator2Options().load_capabilities(desired_caps)
    try:
        print("Attempting to connect to Appium server...")
        driver = webdriver.Remote("http://127.0.0.1:4723", options=options)
        print("âœ… Successfully connected to Appium server.")
        return driver
    except Exception as e:
        print(f"âŒ Failed to connect to Appium server or start session: {e}")
        return None

# --- FunciÃ³n ACTUALIZADA para Guardar Resultados en CSV y TXT ---
def guardar_resultado_y_tiempo_en_archivos(
    tipo_test, ret, latitud, longitud, fecha_hora_inicio, fecha_hora_fin, comentario="OK"
):
    csv_file_path = "metricas_instagram.csv"
    txt_file_path = "tiempos_carga.txt" # Path para el archivo TXT

    # --- Escribir en CSV ---
    file_exists = os.path.isfile(csv_file_path)
    is_empty = os.path.getsize(csv_file_path) == 0 if file_exists else True

    with open(csv_file_path, "a", newline="", encoding="utf-8") as csv_file:
        writer = csv.writer(csv_file)
        if not file_exists or is_empty:
            writer.writerow([
                "Instagram", "Tipo de test", "Ret", "Latitud", "Longitud",
                "Fecha_Hora_Inicio", "Fecha_Hora_Fin", "Comentario"
            ])
        writer.writerow([
            "Instagram", tipo_test, ret, latitud, longitud,
            fecha_hora_inicio, fecha_hora_fin, comentario
        ])
    print(f"ðŸ“ MÃ©trica guardada en '{csv_file_path}'.")

    # --- Escribir en TXT ---
    # Calcular la duraciÃ³n para el archivo TXT
    # Convertir a datetime objects para calcular la diferencia
    fmt = "%Y-%m-%d %H:%M:%S.%f"
    start_dt = datetime.strptime(fecha_hora_inicio, fmt)
    end_dt = datetime.strptime(fecha_hora_fin, fmt)
    duration_seconds = (end_dt - start_dt).total_seconds()

    with open(txt_file_path, "a", encoding="utf-8") as txt_file:
        txt_file.write(
            f"{fecha_hora_inicio} - {tipo_test}: {duration_seconds:.2f} segundos. "
            f"Inicio: {fecha_hora_inicio}, Fin: {fecha_hora_fin}, "
            f"Lat: {latitud}, Lon: {longitud}, Comentario: {comentario}\n"
        )
    print(f"ðŸ“ Tiempo guardado en '{txt_file_path}'.")


# --- Resto de las funciones (get_device_location, measure_app_open_to_feed_time,
# enter_text_id, enter_text_ui, click_button, click_tab_icon, is_logged_in,
# find_elements_safely, random_photo, asegurar_publicacion_activa, select_from_gallery)
# sin cambios. No las incluyo aquÃ­ para evitar la repeticiÃ³n del cÃ³digo que ya funciona.
# AsegÃºrate de copiarlas desde tu script original o desde mi Ãºltima respuesta. ---

# Incluyo las funciones de interacciÃ³n aquÃ­ para que el cÃ³digo sea completo y runnable.
# Si ya las tienes en tu archivo, no necesitas pegarlas de nuevo.

def get_device_location(driver):
    latitude, longitude = "N/A", "N/A"
    try:
        location = driver.location
        if location and 'latitude' in location and 'longitude' in location:
            latitude = str(location['latitude'])
            longitude = str(location['longitude'])
            print(f"ðŸŒ UbicaciÃ³n del dispositivo: Lat {latitude}, Lon {longitude}")
        else:
            print("âš ï¸ No se pudo obtener la ubicaciÃ³n (driver.location retornÃ³ None o incompleto).")
    except Exception as e:
        print(f"âŒ Error al obtener la ubicaciÃ³n del dispositivo: {e}")
        print("AsegÃºrate de que los servicios de ubicaciÃ³n estÃ©n activados y Appium tenga permisos.")
    return latitude, longitude

def measure_app_open_to_feed_time(driver):
    print("\nâ±ï¸ MediciÃ³n: Tiempo desde apertura de app hasta carga del For You Page...")
    try:
        WebDriverWait(driver, 45).until(
            EC.any_of(
                EC.presence_of_element_located((AppiumBy.ID, "com.instagram.android:id/recycler_view")),
                EC.presence_of_element_located((AppiumBy.ID, "com.instagram.android:id/refreshable_container")),
            )
        )
        print("âœ… Feed (For You page) detectado por uno de los indicadores comunes.")
        return True
    except TimeoutException:
        print("âŒ No se pudo detectar el contenedor del feed/FYP (indicadores comunes) en 45 segundos.")
        return False
    except Exception as e:
        print(f"âŒ Error al esperar el feed: {e}")
        return False

def enter_text_id(driver, resource_id, text_to_enter, description="",timeout=15):
    print(f"Buscando '{description}' para ingresar texto...")
    try:
        text_field = WebDriverWait(driver, timeout).until(
            EC.presence_of_element_located((AppiumBy.ID, resource_id))
        )
        text_field.clear()
        text_field.send_keys(text_to_enter)
        print(f"âœ… Texto ingresado exitosamente en '{description}'")
        time.sleep(0.5)
        return True
    except TimeoutException:
        print(f"âŒ El '{description}'no se encontrÃ³ en {timeout} segundos.")
        return False
    except Exception as e:
        print(f"âŒ Error al ingresar texto en '{description}'): {e}")
        return False

def enter_text_ui(driver, uiautomator_string, text_to_enter, description="", timeout=15):
    print(f"Buscando '{description}' para ingresar texto...")
    try:
        text_field = WebDriverWait(driver, timeout).until(
            EC.presence_of_element_located((AppiumBy.ANDROID_UIAUTOMATOR, uiautomator_string))
        )
        text_field.clear()
        text_field.send_keys(text_to_enter)
        print(f"âœ… Texto ingresado exitosamente en '{description}': '{text_to_enter}'")
        time.sleep(0.5)
        return True
    except TimeoutException:
        print(f"âŒ El '{description}' no se encontrÃ³ en {timeout} segundos.")
        return False
    except Exception as e:
        print(f"âŒ Error al ingresar texto en '{description}' {e}")
        return False

def click_button(driver, resource_id, description="", timeout=15, mandatory=True):
    print(f"ðŸ” Esperando {description} (ID: {resource_id})")
    try:
        button = WebDriverWait(driver, timeout).until(
            EC.element_to_be_clickable((
                AppiumBy.ANDROID_UIAUTOMATOR,
                f'new UiSelector().resourceId("{resource_id}").enabled(true)'
            ))
        )
        button.click()
        print(f"âœ… Click exitoso en: {description}")
        time.sleep(.5)
        return True
    except Exception as e:
        print(f"âŒ FallÃ³ el clic en {description}: {e}")
        if mandatory:
            raise
        return False

def click_tab_icon(driver, resource_id, instance_index=0, description="", timeout=15, mandatory=True):
    print(f"ðŸ” Esperando {description} (ID: {resource_id}, Instancia: {instance_index})")
    try:
        icon = WebDriverWait(driver, timeout).until(
            EC.element_to_be_clickable((
                AppiumBy.ANDROID_UIAUTOMATOR,
                f'new UiSelector().resourceId("{resource_id}").instance({instance_index}).enabled(true)'
            ))
        )
        icon.click()
        print(f"âœ… Click exitoso en: {description}")
        time.sleep(.5)
        return True
    except Exception as e:
        print(f"âŒ FallÃ³ el clic en {description}: {e}")
        if mandatory:
            raise
        return False

def is_logged_in(driver):
    print("Checking if already logged in by looking for Instagram logo or feed...")
    try:
        WebDriverWait(driver, 7).until( # Ligeramente mÃ¡s tiempo
            EC.any_of(
                EC.presence_of_element_located((AppiumBy.ID, "com.instagram.android:id/title_logo")),
                EC.presence_of_element_located((AppiumBy.ID, "com.instagram.android:id/feed_tab_icon")),
            )
        )
        print("âœ… User appears to be logged in.")
        return True
    except TimeoutException:
        print("âŒ User is likely not logged in (logo/feed not found quickly).")
        return False
    except Exception as e:
        print(f"An error occurred while checking login status: {e}")
        return False

PHOTO_THUMBNAIL_LOCATORS = [
    (AppiumBy.XPATH, '//android.widget.GridView[@resource-id="com.instagram.android:id/media_picker_grid_view"]//android.widget.Button'),
    (AppiumBy.ANDROID_UIAUTOMATOR, 'new UiSelector().resourceId("com.instagram.android:id/media_picker_grid_view").childSelector(new UiSelector().className("android.widget.Button"))'),
    (AppiumBy.CLASS_NAME, "android.widget.Button"),
]
"""""
PHOTO_THUMBNAIL = [
    (AppiumBy.XPATH, '//android.widget.GridView[@resource-id="com.instagram.android:id/media_picker_grid_view"]//android.widget.Button'),
    (AppiumBy.ANDROID_UIAUTOMATOR, 'new UiSelector().resourceId("com.instagram.android:id/media_picker_grid_view").childSelector(new UiSelector().className("android.widget.Button"))'),
    (AppiumBy.CLASS_NAME, "android.widget.Button"),
]
def select_from_grid(driver, photo_index, thumbnail_locators=PHOTO_THUMBNAIL, timeout=15):

    print(f"\n--- Intentando seleccionar la miniatura de foto/video en la galerÃ­a (Ã­ndice: {photo_index}) ---")
    
    photo_elements = []
    # Itera sobre los locators para encontrar cualquier elemento de foto
    for by, value in thumbnail_locators:
        photo_elements = find_elements_safely(driver, by, value, timeout=timeout, description=f"Miniaturas de fotos con {by.value}:'{value}'")
        if photo_elements:
            break # Si encontramos elementos con un selector, salimos del bucle

    if not photo_elements:
        print(f"âŒ No se encontraron miniaturas de fotos con ninguno de los selectores proporcionados.")
        return False

    if photo_index >= len(photo_elements) or photo_index < 0:
        print(f"âš ï¸ Ãndice de foto fuera de rango. Se solicitÃ³ el Ã­ndice {photo_index}, pero solo se encontraron {len(photo_elements)} fotos.")
        return False

    try:
        specific_photo = photo_elements[photo_index]
        
        photo_description = specific_photo.get_attribute('content-desc') or specific_photo.text or f"miniatura en Ã­ndice {photo_index} (clase: {specific_photo.tag_name})"
        print(f"âœ… Seleccionando miniatura de foto/video: '{photo_description}'")
        
        specific_photo.click()
        print(f"âœ… Clic en miniatura de foto/video en Ã­ndice {photo_index} exitoso.")
        time.sleep(2) # Esperar a que la foto se abra o cargue la siguiente pantalla
        return True
    except Exception as e:
        print(f"âŒ Error al intentar hacer clic en la miniatura de foto/video en el Ã­ndice {photo_index}: {e}")
        return False
"""""



def find_elements_safely(driver, by, value, timeout=10, description="Elementos"):
    try:
        print(f"Buscando '{description}' con el localizador {by} y valor '{value}'...")
        
        WebDriverWait(driver, timeout).until(EC.presence_of_all_elements_located((by, value)))
        elements = driver.find_elements(by, value)
        print(f"âœ… Se encontraron {len(elements)} elementos para '{description}'.")
        return elements
    except TimeoutException:
        print(f"âŒ No se encontraron elementos para '{description}' en {timeout} segundos.")
        return []
    except Exception as e:
        print(f"âŒ Error al buscar elementos para '{description}': {e}")
        return []

def random_photo(driver, thumbnail_locators): # Added parameters
    print("\n--- Intentando seleccionar una miniatura de foto aleatoriamente ---")
    photo_elements = []
    for by, value in thumbnail_locators: # Use the passed-in locators
        photo_elements = find_elements_safely(driver, by, value, timeout=10, description="Miniaturas de fotos")
        if photo_elements:
            break # Si encontramos elementos con un selector, salimos del bucle de selectores
            
    if photo_elements:
        random_photo = random.choice(photo_elements)
        # Intentar obtener el atributo 'content-desc' o 'text' para imprimirlo.
        photo_description = random_photo.get_attribute('content-desc') or random_photo.text or f"Elemento (Clase: {random_photo.tag_name})"
        print(f"âœ… Seleccionando miniatura de foto aleatoria: '{photo_description}'")
        random_photo.click()
        print("âœ… Clic en miniatura de foto exitoso.")
        time.sleep(2) # Esperar a que la foto se abra en pantalla completa
    else:
        raise Exception("âŒ No se encontraron miniaturas de fotos para seleccionar con los selectores proporcionados.")

def asegurar_publicacion_activa(driver, timeout=5):
    print("\nðŸ” Verificando si la opciÃ³n 'PUBLICACIÃ“N' estÃ¡ activa...")

    try:
        # Intentar encontrar la opciÃ³n activa con content-desc "PUBLICACIÃ“N"
        elemento_publicacion = WebDriverWait(driver, timeout).until(
            EC.presence_of_element_located((
                AppiumBy.XPATH,
                '//android.widget.TextView[@content-desc="PUBLICACIÃ“N"]'
            ))
        )

        if elemento_publicacion.is_selected() or "selected" in (elemento_publicacion.get_attribute("selected") or ""):
            print("âœ… Ya estÃ¡ seleccionada la opciÃ³n 'PUBLICACIÃ“N'.")
            return True
        else:
            print("â„¹ï¸ OpciÃ³n 'PUBLICACIÃ“N' no estÃ¡ activa. Intentando activarla...")
            return click_button(driver, "com.instagram.android:id/cam_dest_feed", "OpciÃ³n 'PUBLICACIÃ“N'")
    
    except Exception as e:
        print(f"âŒ No se pudo verificar o seleccionar 'PUBLICACIÃ“N': {e}")
        return False
    

def select_from_gallery(driver, instance_index, gallery_id="com.instagram.android:id/gallery_grid", thumbnail_class_name="android.widget.CheckBox", timeout=15):
    print(f"\n--- Intentando seleccionar la miniatura de foto/video de la galerÃ­a")
    
    uiautomator_selector = (
        f'new UiSelector().resourceId("{gallery_id}")'
        f'.childSelector(new UiSelector().className("{thumbnail_class_name}").instance({instance_index}))'
    )

    try:
        photo_thumbnail = WebDriverWait(driver, timeout).until(
            EC.presence_of_element_located((AppiumBy.ANDROID_UIAUTOMATOR, uiautomator_selector))
        )
        
        photo_description = photo_thumbnail.get_attribute('content-desc') or photo_thumbnail.text or f"miniatura en Ã­ndice {instance_index} de la galerÃ­a"
        print(f"âœ… Seleccionando miniatura de foto/video: '{photo_description}'")
        photo_thumbnail.click()
        print(f"âœ… Clic en miniatura de foto/video en Ã­ndice {instance_index} exitoso.")
        time.sleep(2) # Esperar a que la foto se abra
        return True
    except TimeoutException:
        print(f"âŒ No se encontrÃ³ la miniatura de foto/video en {timeout} segundos.")
        return False
    except NoSuchElementException: 
        print(f"âŒ La miniatura de foto/video en el Ã­ndice no se encontrÃ³ inmediatamente.")
        return False
    except Exception as e:
        print(f"âŒ Error al intentar hacer clic en la miniatura de foto/video en el Ã­ndice  {e}")
        return False




# --- FunciÃ³n Principal de AutomatizaciÃ³n con Mediciones de UbicaciÃ³n ---
def test_instagram_automation():
    driver = None
    Red = None
    try:
        driver = setup_driver()
        Red = obtener_estado_conectividad_real(driver)
        if driver:
            print("\n--- Instagram Automation Started ---")
            
            # --- 1. MediciÃ³n: Carga de App a For You Page ---
            lat_inicio_app_feed, lon_inicio_app_feed = get_device_location(driver)
            fecha_hora_inicio_app_feed = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
            
            if measure_app_open_to_feed_time(driver):
                lat_fin_app_feed, lon_fin_app_feed = get_device_location(driver)
                fecha_hora_fin_app_feed = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                guardar_resultado_y_tiempo_en_archivos(
                    METRICA_CARGA_APP_A_FEED, Red, lat_inicio_app_feed, lon_inicio_app_feed,
                    fecha_hora_inicio_app_feed, fecha_hora_fin_app_feed, "OK"
                )
            else:
                lat_fin_app_feed, lon_fin_app_feed = get_device_location(driver)
                fecha_hora_fin_app_feed = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                guardar_resultado_y_tiempo_en_archivos(
                    METRICA_CARGA_APP_A_FEED, Red, lat_inicio_app_feed, lon_inicio_app_feed,
                    fecha_hora_inicio_app_feed, fecha_hora_fin_app_feed, "Feed no detectado"
                )
                print("âš ï¸ No se pudo medir el tiempo de carga del feed porque el feed no se detectÃ³.")
                return

            # --- Proceso de Login (si es necesario) ---
            if not is_logged_in(driver):
                print("User is not logged in. Proceeding with login flow.")
            else:
                print("Skipping login process as user is already logged in.")
                time.sleep(2)

            # --- 2. Flujo de PublicaciÃ³n de Post ---
            click_tab_icon(driver, "com.instagram.android:id/tab_avatar", instance_index=0, description="Icono perfil (Avatar Tab)")
            click_tab_icon(driver, "com.instagram.android:id/tab_icon", instance_index=2, description="Icono crear (+) - Middle Tab Icon", timeout=10)
            print("âœ… 'Crear (+)' icon clicked successfully.")
            
            if not asegurar_publicacion_activa(driver):
                print("âŒ No se pudo asegurar la opciÃ³n 'PUBLICACIÃ“N'. Abortando publicaciÃ³n.")
                return

            
            #select_from_grid(driver,3)
            random_photo(driver, PHOTO_THUMBNAIL_LOCATORS)
            click_button(driver, "com.instagram.android:id/next_button_textview", "BotÃ³n Siguiente (SelecciÃ³n de Media)")
            click_button(driver, "com.instagram.android:id/creation_next_button", "BotÃ³n Next creaciÃ³n")
            
            lat_inicio_post, lon_inicio_post = get_device_location(driver)
            fecha_hora_inicio_post = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
            print("\nâ±ï¸ MediciÃ³n: Tiempo de publicaciÃ³n del post...")
            
            if click_button(driver, "com.instagram.android:id/share_footer_button", "BotÃ³n Compartir publicaciÃ³n"):
                try:
                    WebDriverWait(driver, 90).until(
                        EC.any_of(
                            EC.invisibility_of_element_located((AppiumBy.XPATH, "//*[contains(@text, 'Finalizando') or contains(@text, 'Finishing')]")),
                            EC.invisibility_of_element_located((AppiumBy.XPATH, "//*[contains(@text, 'Compartiendo') or contains(@text, 'Sharing')]")),
                            EC.element_to_be_clickable((AppiumBy.ID, "com.instagram.android:id/feed_tab_icon"))
                        )
                    )
                    lat_fin_post, lon_fin_post = get_device_location(driver)
                    fecha_hora_fin_post = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                    print(f"âœ… PublicaciÃ³n completada y confirmada.")
                    guardar_resultado_y_tiempo_en_archivos(
                        METRICA_PUBLICACION_POST, Red, lat_inicio_post, lon_inicio_post,
                        fecha_hora_inicio_post, fecha_hora_fin_post, "OK"
                    )
                except TimeoutException:
                    lat_fin_post, lon_fin_post = get_device_location(driver)
                    fecha_hora_fin_post = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                    print(f"âš ï¸ No se pudo confirmar la finalizaciÃ³n de la publicaciÃ³n en 90s (timeout).")
                    guardar_resultado_y_tiempo_en_archivos(
                        METRICA_PUBLICACION_POST, Red, lat_inicio_post, lon_inicio_post,
                        fecha_hora_inicio_post, fecha_hora_fin_post, "Timeout de confirmaciÃ³n"
                    )
            else:
                lat_fin_post, lon_fin_post = get_device_location(driver)
                fecha_hora_fin_post = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                guardar_resultado_y_tiempo_en_archivos(
                    METRICA_PUBLICACION_POST, Red, lat_inicio_post, lon_inicio_post,
                    fecha_hora_inicio_post, fecha_hora_fin_post, "No se hizo clic en Compartir"
                )
                print("âŒ No se pudo hacer clic en Compartir, no se medirÃ¡ el tiempo de publicaciÃ³n.")

            # --- 3. Flujo de Mensaje de Texto ---
            time.sleep(2)
            click_button(driver, "com.instagram.android:id/action_bar_inbox_button", "BotÃ³n Inbox (Mensajes)")
            click_button(driver, "com.instagram.android:id/row_inbox_container", "Entrar al Primer Chat")

            lat_inicio_msg_texto, lon_inicio_msg_texto = get_device_location(driver)
            fecha_hora_inicio_msg_texto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
            print("\nâ±ï¸ MediciÃ³n: Tiempo de envÃ­o de mensaje de texto...")

            if enter_text_ui(driver, 'new UiSelector().resourceId("com.instagram.android:id/row_thread_composer_edittext")', "Hola prueba", "Escribir un hola"):
                if click_button(driver, "com.instagram.android:id/row_thread_composer_send_button_container","Enviar mensaje", mandatory=False, timeout=7):
                    try:
                        print("ðŸ” Esperando desapariciÃ³n de 'action_icon' o spinner para confirmar envÃ­o de texto...")
                        WebDriverWait(driver, 30).until(
                            EC.invisibility_of_element_located((AppiumBy.ID, "com.instagram.android:id/action_icon"))
                        )
                        lat_fin_msg_texto, lon_fin_msg_texto = get_device_location(driver)
                        fecha_hora_fin_msg_texto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                        print(f"âœ… Mensaje de texto enviado y confirmado.")
                        guardar_resultado_y_tiempo_en_archivos(
                            METRICA_ENVIO_MSG_TEXTO, Red, lat_inicio_msg_texto, lon_inicio_msg_texto,
                            fecha_hora_inicio_msg_texto, fecha_hora_fin_msg_texto, "OK"
                        )
                    except TimeoutException:
                        lat_fin_msg_texto, lon_fin_msg_texto = get_device_location(driver)
                        fecha_hora_fin_msg_texto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                        print(f"âš ï¸ No se pudo confirmar el envÃ­o del mensaje de texto en 30s (timeout).")
                        guardar_resultado_y_tiempo_en_archivos(
                            METRICA_ENVIO_MSG_TEXTO, Red, lat_inicio_msg_texto, lon_inicio_msg_texto,
                            fecha_hora_inicio_msg_texto, fecha_hora_fin_msg_texto, "Timeout de confirmaciÃ³n"
                        )
                else:
                    lat_fin_msg_texto, lon_fin_msg_texto = get_device_location(driver)
                    fecha_hora_fin_msg_texto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                    guardar_resultado_y_tiempo_en_archivos(
                        METRICA_ENVIO_MSG_TEXTO, Red, lat_inicio_msg_texto, lon_inicio_msg_texto,
                        fecha_hora_inicio_msg_texto, fecha_hora_fin_msg_texto, "No se hizo clic en Enviar"
                    )
                    print("âŒ No se pudo hacer clic en Enviar Mensaje, no se medirÃ¡ el tiempo.")
            else:
                lat_fin_msg_texto, lon_fin_msg_texto = get_device_location(driver)
                fecha_hora_fin_msg_texto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                guardar_resultado_y_tiempo_en_archivos(
                    METRICA_ENVIO_MSG_TEXTO, Red, lat_inicio_msg_texto, lon_inicio_msg_texto,
                    fecha_hora_inicio_msg_texto, fecha_hora_fin_msg_texto, "No se pudo ingresar texto"
                )
                print("âŒ No se pudo ingresar texto, no se medirÃ¡ el tiempo de envÃ­o.")

            # --- 4. Flujo de Mensaje con Foto ---
            time.sleep(2)
            if click_button(driver, "com.instagram.android:id/row_thread_composer_button_gallery", "BotÃ³n GalerÃ­a"):
                if select_from_gallery(driver, 2):
                    lat_inicio_msg_foto, lon_inicio_msg_foto = get_device_location(driver)
                    fecha_hora_inicio_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                    print("\nâ±ï¸ MediciÃ³n: Tiempo de envÃ­o de mensaje con foto...")
                    
                    if click_button(driver, "com.instagram.android:id/media_thumbnail_tray_button","Enviar foto", mandatory=False, timeout=7):
                        try:
                            print("ðŸ” Esperando desapariciÃ³n de 'action_icon' o spinner para confirmar envÃ­o de foto...")
                            WebDriverWait(driver, 60).until(
                                EC.invisibility_of_element_located((AppiumBy.ID, "com.instagram.android:id/action_icon"))
                            )
                            lat_fin_msg_foto, lon_fin_msg_foto = get_device_location(driver)
                            fecha_hora_fin_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                            print(f"âœ… Mensaje con foto enviado y confirmado.")
                            guardar_resultado_y_tiempo_en_archivos(
                                METRICA_ENVIO_MSG_FOTO, Red, lat_inicio_msg_foto, lon_inicio_msg_foto,
                                fecha_hora_inicio_msg_foto, fecha_hora_fin_msg_foto, "OK"
                            )
                        except TimeoutException:
                            lat_fin_msg_foto, lon_fin_msg_foto = get_device_location(driver)
                            fecha_hora_fin_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                            print(f"âš ï¸ No se pudo confirmar el envÃ­o de la foto en 60s (timeout).")
                            guardar_resultado_y_tiempo_en_archivos(
                                METRICA_ENVIO_MSG_FOTO, Red, lat_inicio_msg_foto, lon_inicio_msg_foto,
                                fecha_hora_inicio_msg_foto, fecha_hora_fin_msg_foto, "Timeout de confirmaciÃ³n"
                            )
                    else:
                        lat_fin_msg_foto, lon_fin_msg_foto = get_device_location(driver)
                        fecha_hora_fin_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                        guardar_resultado_y_tiempo_en_archivos(
                            METRICA_ENVIO_MSG_FOTO, Red, lat_inicio_msg_foto, lon_inicio_msg_foto,
                            fecha_hora_inicio_msg_foto, fecha_hora_fin_msg_foto, "No se hizo clic en Enviar Foto"
                        )
                        print(f"âŒ No se pudo hacer clic en Enviar Foto Seleccionada, no se medirÃ¡ el tiempo.")
                else:
                    lat_fin_msg_foto, lon_fin_msg_foto = get_device_location(driver)
                    fecha_hora_fin_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                    guardar_resultado_y_tiempo_en_archivos(
                        METRICA_ENVIO_MSG_FOTO, Red, lat_inicio_msg_foto, lon_inicio_msg_foto,
                        fecha_hora_inicio_msg_foto, fecha_hora_fin_msg_foto, "No se pudo seleccionar foto"
                    )
                    print("âŒ No se pudo seleccionar una foto de la galerÃ­a del chat.")
            else:
                lat_fin_msg_foto, lon_fin_msg_foto = get_device_location(driver)
                fecha_hora_fin_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                guardar_resultado_y_tiempo_en_archivos(
                    METRICA_ENVIO_MSG_FOTO, Red, lat_inicio_msg_foto, lon_inicio_msg_foto,
                    fecha_hora_inicio_msg_foto, fecha_hora_fin_msg_foto, "No se hizo clic en BotÃ³n GalerÃ­a"
                )
                print("âŒ No se pudo hacer clic en el botÃ³n de GalerÃ­a en el chat.")

            print("\nâœ… Flujo principal de acciones completado.")

            time.sleep(2)


                        # --- 5. Flujo de Mensaje con Video ---
            time.sleep(2)
            if click_button(driver, "com.instagram.android:id/row_thread_composer_button_gallery", "BotÃ³n GalerÃ­a"):
                if select_from_gallery(driver, 0):
                    lat_inicio_msg_foto, lon_inicio_msg_foto = get_device_location(driver)
                    fecha_hora_inicio_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                    print("\nâ±ï¸ MediciÃ³n: Tiempo de envÃ­o de mensaje con Video...")
                    
                    if click_button(driver, "com.instagram.android:id/media_thumbnail_tray_button","Enviar Video", mandatory=False, timeout=7):
                        try:
                            print("ðŸ” Esperando desapariciÃ³n de 'action_icon' o spinner para confirmar envÃ­o de Video...")
                            time.sleep(3)
                            WebDriverWait(driver, 60).until(
                                EC.invisibility_of_element_located((AppiumBy.ID, "com.instagram.android:id/action_icon"))
                            )
                            lat_fin_msg_foto, lon_fin_msg_foto = get_device_location(driver)
                            fecha_hora_fin_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                            print(f"âœ… Mensaje con foto enviado y confirmado.")
                            guardar_resultado_y_tiempo_en_archivos(
                                METRICA_ENVIO_MSG_VIDEO, Red, lat_inicio_msg_foto, lon_inicio_msg_foto,
                                fecha_hora_inicio_msg_foto, fecha_hora_fin_msg_foto, "OK"
                            )
                        except TimeoutException:
                            lat_fin_msg_foto, lon_fin_msg_foto = get_device_location(driver)
                            fecha_hora_fin_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                            print(f"âš ï¸ No se pudo confirmar el envÃ­o de la foto en 60s (timeout).")
                            guardar_resultado_y_tiempo_en_archivos(
                                METRICA_ENVIO_MSG_VIDEO, Red, lat_inicio_msg_foto, lon_inicio_msg_foto,
                                fecha_hora_inicio_msg_foto, fecha_hora_fin_msg_foto, "Timeout de confirmaciÃ³n"
                            )
                    else:
                        lat_fin_msg_foto, lon_fin_msg_foto = get_device_location(driver)
                        fecha_hora_fin_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                        guardar_resultado_y_tiempo_en_archivos(
                            METRICA_ENVIO_MSG_VIDEO, Red, lat_inicio_msg_foto, lon_inicio_msg_foto,
                            fecha_hora_inicio_msg_foto, fecha_hora_fin_msg_foto, "No se hizo clic en Enviar Foto"
                        )
                        print(f"âŒ No se pudo hacer clic en Enviar Foto Seleccionada, no se medirÃ¡ el tiempo.")
                else:
                    lat_fin_msg_foto, lon_fin_msg_foto = get_device_location(driver)
                    fecha_hora_fin_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                    guardar_resultado_y_tiempo_en_archivos(
                        METRICA_ENVIO_MSG_VIDEO, Red, lat_inicio_msg_foto, lon_inicio_msg_foto,
                        fecha_hora_inicio_msg_foto, fecha_hora_fin_msg_foto, "No se pudo seleccionar foto"
                    )
                    print("âŒ No se pudo seleccionar una foto de la galerÃ­a del chat.")
            else:
                lat_fin_msg_foto, lon_fin_msg_foto = get_device_location(driver)
                fecha_hora_fin_msg_foto = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                guardar_resultado_y_tiempo_en_archivos(
                    METRICA_ENVIO_MSG_VIDEO, Red, lat_inicio_msg_foto, lon_inicio_msg_foto,
                    fecha_hora_inicio_msg_foto, fecha_hora_fin_msg_foto, "No se hizo clic en BotÃ³n GalerÃ­a"
                )
                print("âŒ No se pudo hacer clic en el botÃ³n de GalerÃ­a en el chat.")

            print("\nâœ… Flujo principal de acciones completado.")

            time.sleep(2)






    except Exception as e:
        print(f"âŒ An error occurred during the test: {e}")
        if driver:
            timestamp_error = datetime.now().strftime("%Y%m%d_%H%M%S")
            error_screenshot_filename = f"error_general_test_{timestamp_error}.png"
            try:
                driver.save_screenshot(error_screenshot_filename)
                print(f"Screenshot saved as '{error_screenshot_filename}'.")
            except Exception as e_screenshot:
                print(f"Failed to save screenshot: {e_screenshot}")
    finally:
        print("\n--- Automation Finished ---")
        if driver:
            driver.quit()
            print("Driver quit.")


if __name__ == "__main__":


    csv_file_path = "metricas_instagram.csv"

    # Crear archivo si no existe o estÃ¡ vacÃ­o
    if not os.path.isfile(csv_file_path) or os.path.getsize(csv_file_path) == 0:
        with open(csv_file_path, "w", newline="", encoding="utf-8") as csv_file:
            writer = csv.writer(csv_file)
            writer.writerow([
                "Instagram", "Tipo de test", "Ret", "Latitud", "Longitud",
                "Fecha_Hora_Inicio", "Fecha_Hora_Fin", "Comentario"
            ])
        print(f"ðŸ“„ Archivo '{csv_file_path}' creado/inicializado con cabecera.")

    # NÃºmero de repeticiones
    
    repeticiones = 2

    for i in range(repeticiones):
        print(f"\nðŸ” Ejecutando iteraciÃ³n {i + 1} de {repeticiones}...")
        try:
            test_instagram_automation()
        except Exception as e:
            print(f"âŒ Error en la iteraciÃ³n {i + 1}: {e}")