# -*- coding: utf-8 -*-
import datetime

# Contenido Markdown con emojis y formato enriquecido
markdown_content = f"""# ğŸ–¥ï¸ GuÃ­a TÃ©cnica Completa: Pantalla SPI 3.5" en Raspberry Pi

**Autor**: ChatGPT â€“ OpenAI  
**Fecha**: {datetime.date.today().strftime("%d/%m/%Y")}

---

## ğŸ“‘ Ãndice

1. ğŸ§  IntroducciÃ³n  
2. ğŸ”Œ ConexiÃ³n fÃ­sica y pines  
3. ğŸ§± QuÃ© es el kernel  
4. âš™ï¸ QuÃ© es un driver/controlador  
5. ğŸ”„ ComunicaciÃ³n SPI en detalle  
6. ğŸ–¼ï¸ QuÃ© es y cÃ³mo funciona el framebuffer  
7. ğŸ® HDMI vs SPI  
8. ğŸ§© DRM/KMS y overlays  
9. ğŸªŸ Wayland vs X11  
10. ğŸ” Flujo completo de software y hardware  
11. ğŸ“‚ Archivos y rutas clave  
12. âŒ Errores comunes  
13. ğŸ§­ Resumen visual  
14. âœ… SoluciÃ³n funcional paso a paso

---

## ğŸ§  1. IntroducciÃ³n

Esta guÃ­a explica el funcionamiento tÃ©cnico de pantallas SPI de 3.5â€ en Raspberry Pi, en sistemas modernos como RPi OS Bookworm. Cubre desde la conexiÃ³n elÃ©ctrica hasta la configuraciÃ³n del entorno grÃ¡fico.

---

## ğŸ”Œ 2. ConexiÃ³n fÃ­sica y pines

Aunque SPI usa pocos pines (MOSI, SCLK, CS, DC, RESET), las pantallas suelen usar 30+ pines por diseÃ±o fÃ­sico:
- Pines repetidos (varios GND o VCC)
- Pines reservados o sin uso
- Pines extra para touchscreen (I2C o SPI)
- Conector pensado para encajar completo sobre el GPIO de la Pi

---

## ğŸ§± 3. QuÃ© es el kernel

El **kernel** es el nÃºcleo del sistema operativo. Administra:
- Acceso a hardware (pantalla, red, USB)
- Recursos como memoria y CPU
- ComunicaciÃ³n con programas mediante syscalls

En Raspberry Pi usamos un **kernel Linux personalizado** con soporte a GPIO, SPI, cÃ¡mara, pantallas, etc.

---

## âš™ï¸ 4. QuÃ© es un driver/controlador

Un **driver** (o controlador) es software que enseÃ±a al kernel cÃ³mo usar un hardware especÃ­fico.

Ejemplo:
- El chip ILI9486 de tu pantalla no se entiende solo
- Se necesita un driver que le diga al kernel cÃ³mo inicializarlo, enviar datos, manejar tÃ¡ctil, etc.

---

## ğŸ”„ 5. ComunicaciÃ³n SPI en detalle

SPI (Serial Peripheral Interface) es un protocolo serial sÃ­ncrono. Usa:
- `MOSI` â€“ datos de la Pi a la pantalla
- `SCLK` â€“ reloj
- `CS` â€“ selecciÃ³n del dispositivo
- `DC`, `RESET` â€“ control
- `MISO` â€“ opcional

ğŸ“¡ SPI transmite datos en serie con sincronizaciÃ³n por reloj. Velocidades tÃ­picas: 16â€“32â€¯MHz.

---

## ğŸ–¼ï¸ 6. QuÃ© es y cÃ³mo funciona el framebuffer

El **framebuffer** es una regiÃ³n de memoria que representa la imagen mostrada.

- `/dev/fb0`: framebuffer HDMI
- `/dev/fb1`: framebuffer SPI (cuando configurado)

X11 o programas grÃ¡ficos escriben sobre esa memoria. El driver se encarga de transferirla a la pantalla fÃ­sica.

---

## ğŸ® 7. HDMI vs SPI

| CaracterÃ­stica        | HDMI             | SPI                    |
|-----------------------|------------------|-------------------------|
| Velocidad             | Alta (Gbps)      | Baja (MHz)              |
| Plug and play         | âœ…                | âŒ (requiere overlay)    |
| ResoluciÃ³n soportada  | Alta (1080p+)    | Limitada (480x320)     |
| Requiere configuraciÃ³n| âŒ                | âœ…                      |
| Driver especÃ­fico     | No               | SÃ­                     |

---

## ğŸ§© 8. DRM/KMS y overlays

- **DRM (Direct Rendering Manager)** y **KMS (Kernel Mode Setting)** son tecnologÃ­as del kernel Linux para manejar grÃ¡ficos modernos.
- Algunos overlays (como `piscreen`) se integran con DRM para que la pantalla SPI se use como pantalla primaria real.

---

## ğŸªŸ 9. Wayland vs X11

| CaracterÃ­stica    | X11           | Wayland         |
|-------------------|---------------|------------------|
| Modelo grÃ¡fico    | Cliente-servidor | Compositor directo |
| Compatibilidad    | Alta           | Media/Baja        |
| Funciona con SPI  | âœ…             | âš ï¸ Parcial        |
| Necesario para evdev | âœ…         | âŒ (incompatible)  |

âœ… En Raspberry Pi OS Bookworm, cambiar de Wayland a X11 es necesario para usar pantallas SPI.

---

## ğŸ” 10. Flujo completo de software y hardware

```plaintext
Software grÃ¡fico
        â†“
       X11
        â†“
   /dev/fb1 (framebuffer SPI)
        â†“
Driver SPI (ILI9486)
        â†“
     GPIO SPI
        â†“
Pantalla SPI 3.5"
TÃ¡ctil (si tiene):

plaintext
Copiar
Editar
Touchscreen
    â†“
/dev/input/eventX
    â†“
Driver evdev
    â†“
Cursor en pantalla
ğŸ“‚ 11. Archivos y rutas clave
/boot/firmware/config.txt â†’ activa overlays

/dev/fb0, /dev/fb1 â†’ framebuffers

/dev/input/event* â†’ eventos tÃ¡ctiles

/usr/share/X11/xorg.conf.d/ â†’ config entrada X11

/lib/modules/ â†’ drivers del kernel

âŒ 12. Errores comunes
Ejecutar LCD35-show en RPi OS moderno â†’ rompe compatibilidad

No cambiar de Wayland a X11

Usar overlays incorrectos
ssh-keygen -R 10.44.191.5

Asumir que SPI es plug-and-play como HDMI

ğŸ§­ 13. Resumen visual
plaintext
Copiar
Editar
[X11] â†’ [/dev/fb1] â†’ [Driver SPI] â†’ [GPIO SPI] â†’ [Pantalla]
âœ… 14. SoluciÃ³n funcional paso a paso
Instalar RPi OS Bookworm (32 bits)

Ejecutar:

bash
Copiar
Editar
sudo rpi-update
sudo raspi-config
Interfaz â†’ habilitar SPI

Avanzado â†’ desactivar Wayland (usar X11)

Editar /boot/firmware/config.txt:

bash
Copiar
Editar
#dtoverlay=vc4-kms-v3d
dtoverlay=piscreen,speed=18000000,drm
Instalar entrada tÃ¡ctil:

bash
Copiar
Editar
sudo apt install xserver-xorg-input-evdev
Reconfigurar evdev:

bash
Copiar
Editar
sudo mv /usr/share/X11/xorg.conf.d/10-evdev.conf /usr/share/X11/xorg.conf.d/45-evdev.conf
sudo nano /usr/share/X11/xorg.conf.d/45-evdev.conf
Agregar al final:

text
Copiar
Editar
Section "InputClass"
    Identifier "evdev touchscreen catchall"
    MatchIsTouchscreen "on"
    MatchDevicePath "/dev/input/event*"
    Driver "evdev"
    Option "InvertX" "false"
    Option "InvertY" "true"
EndSection
Reiniciar y verificar la pantalla.